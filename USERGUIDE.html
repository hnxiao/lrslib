<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.76 [en] (X11; U; Linux 2.2.12 i386) [Netscape]">
   <title>User's Guide for lrs</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000EF" vlink="#55188A" alink="#FF0000">

<ul>
<h3>
&nbsp;User's Guide for lrs - Version 4.1</h3>

<h3>
<font size=+0>July 3, 2001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Copyright(C) 2001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.lab2.kuis.kyoto-u.ac.jp/~avis/lrs.html">
lrs home page</a></font></h3>
</ul>

<h3>
<font size=+0>&nbsp; David Avis&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
avis@cs.mcgill.ca&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://cgm.cs.mcgill.ca/~avis">http://cgm.cs.mcgill.ca/~avis</a></font></h3>

<li>
<a href="#What's New in Version 4.1">What's New in Version 4.1</a></li>

<li>
<a href="#What's New in Version 4.0">What's New in Version 4.0</a></li>

<li>
<a href="#Introduction">Introduction&nbsp; (revised)</a></li>

<li>
<a href="#Installation Section">Installation&nbsp;&nbsp;&nbsp; (revised)</a></li>

<li>
<a href="#File Formats">File Formats&nbsp; (revised)</a></li>

<li>
<a href="#Options">Basic Options&nbsp; (revised)</a></li>

<li>
<a href="#Arithmetic Packages">Arithmetic Packages&nbsp; (new)</a></li>

<li>
<a href="#Estimation">Estimation</a></li>

<li>
<a href="#Linear Programming">Linear Programming</a></li>

<li>
<a href="#Volume Computation">Volume Computation</a></li>

<li>
<a href="#Voronoi Diagrams">Voronoi Diagrams</a></li>

<li>
<a href="#Extreme Point Enumeration and Redundant Inequalities">Extreme
Point Enumeration and Redundant Inequalities</a></li>

<li>
<a href="#Linearities">Linearities&nbsp;&nbsp; (new)</a></li>

<li>
<a href="#Timing and Interrupts">Timing and Interrupts</a></li>

<li>
<a href="#Timing and Interrupts">Error Messages and Troubleshooting</a></li>

<li>
<a href="#Hints and Comments">Hints and Comments</a></li>

<li>
<a href="#Acknowledgements">Acknowledgements and References</a></li>

<h3>

<hr WIDTH="100%"></h3>

<h3>
<a NAME="What's New in Version 4.1"></a>What's New in Version 4.1</h3>
Version 4.1 of<font color="#3333FF"> lrslib</font> contains no substantial
revisions to the basic algorithms, but contains complete garbage collection
and some simple drivers for solving vertex enumeration, convex hull and
linear programming problems on generate polyhedra. The generation of input
internally is simplified by the inclusion of some lpsolve like procedures
to enable easy construction of the constraint matrix. Documentation for
this is contained in <font size=+0><a href="http://cgm.cs.mcgill.ca/~avis/C/lrslib/lrslib.html">http://cgm.cs.mcgill.ca/~avis/C/lrslib/lrslib.html</a></font>
<p>A new feature of the basic package is the <font color="#000099">nonnegative</font>
option that speeds up the solution of problems with H-representation:
<blockquote>b+Ax >= 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x>=0</blockquote>

<hr WIDTH="100%">
<h3>
<a NAME="What's New in Version 4.0"></a>What's New in Version 4.0 (included
in Version 4.1)</h3>
<font size=+0>Version 4.0 of <font color="#3333FF">lrs</font> is distributed
as the callable library <font color="#3333FF">lrslib</font>. Two drivers
are supplied, <font color="#3333FF">lrs.c</font> and <font color="#3333FF">redund.c</font>,
that replace the corresponding programs in previous distributions. The
new programs should be compatible with earlier ones, and correctly process
existing input files. New in this version is that input files need not
be of full dimension, and input equations or <a href="#Linearities">linearities</a>
may be specified. In addition, input files may contain redundant columns,
which are closely connected to linearities. See also the section
<a href="#File Formats">File
Formats</a> for more information.</font>
<p>This distribution also comes with three&nbsp; <a href="#Arithmetic Packages">arithmetic</a>
lpackages:<font color="#3333FF"> lrsmp,</font> <font color="#3333FF">lrslong
</font><font color="#000000">and
</font><font color="#3333FF">lrsgmp</font>.
The library lrsmp is essentially the same extended precision package included
in earlier distributions. lrslong is an implementation using long integer
arithmetic, which is considerably faster, but does no overflow checking.
lrsgmp is an interface to<a href="http://www.swox.com/gmp"> GNU MP</a>
which must be installed first. Binaries are produced for all arithmetic
packages using the distributed make file.
<p>Most of the functions required for <font color="#3333FF">lrs</font>
and <font color="#3333FF">redund</font> are included in the library<font color="#3333FF">
lrslib</font>. This is compiled with either of the arithmetic packages.
One of the purposes of supplying a library is to allow simple customization
of the reverse search procedure. The program <font color="#3333FF">lrs.c</font>
is the reverse search driver, and supplies each output vector to the user.
It can be customized to prune the search according to various criteria,
eg., if the value of some objective function falls below some value, or
if an integer vector is produced etc.
<p>The <a href="#Installation Section">installation</a> procedure has been
simplified, and the package is distributed as a compressed tar file. Included
is a makefile for various configurations and some typical input files.
Binaries are also included for some platforms.
<p>There are new options:&nbsp; <a href="#Options">incidence</a>, which
lists all inequalities (resp. vertices/rays) which are incident with the
current output vertex/ray (resp. facet). and <a href="#Options">truncate</a>
which prunes the search tree everytime a vertex different from the starting
vertex is reached.
<br>
<hr WIDTH="100%">
<h3>
<a NAME="Introduction"></a>Introduction</h3>
A polyhedron can be described by a list of inequalities (<i>H-representation)</i>
or as by a list of its vertices and extreme rays (<i>V-representation).lrs
</i>is
a C program that converts a H-representation of a polyhedron to its V-representation,
and vice versa.&nbsp; These problems are known respectively at the <i>vertex
enumeration</i> and <i>convex hull problems</i>.
<br>Fukuda's <a href="http://www.ifor.math.ethz.ch/ifor/staff/fukuda/polyfaq/polyfaq.html">FAQ
page</a>&nbsp; contains a more detailed introduction to the problem, along
with many useful tips for the new user.
<p><i>lrs</i> is based on the <i>reverse search</i> algorithm of <a href="ftp://mutt.cs.mcgill.ca/pub/doc/avis/AF92b.ps.gz">Avis
and Fukuda(1992)</a>, modified to use lexicographic pivoting&nbsp; and
implemented in rational arithmetic. See <a href="ftp://mutt.cs.mcgill.ca/pub/doc/avis/Av98a.ps.gz">Avis(1998a)
</a>for
a technical description, and <a href="ftp://mutt.cs.mcgill.ca/pub/doc/avis/Av98b.ps.gz">Avis(1998b)</a>
for some computational experience. The input files are in <i>Polyhedra
format</i>, developed by Fukuda and the author. The format is essentially
self-dual, and the output file produced can be read in as an input file,
with very minor modifications, to perform the reverse transformation. This
format is compatible with that&nbsp; used in Fukuda's <i><a href="http://www.ifor.math.ethz.ch/staff/fukuda/cdd_home/cdd.html">cdd
</a></i>package,
which performs the same transformations using a version of the <i>double
description method</i>.&nbsp; <i>cdd</i> can also be used&nbsp; in conjunction
with <i>lrs </i>as a pre-processor for projections to subspaces, or as
a post processor for computing various adjacencies and incidences between
the V and H-representations. Another program using the same file format
is the primal-dual method <i>pd,</i> developed by <a href="http://wwwjn.inf.ethz.ch/ambros/pd.html">Bremner,
Fukuda and Marzetta(1997)</a>.&nbsp; It is essentially dual to <i>lrs,</i>
and is very efficient for computing H-representations of simple polyhedra,
and V-representations of simplicial polyhedra. It will compute the volume
of a polytope given by an H-representation.
<p>Another program&nbsp; based on the double description method is Christof
and Loebel's <i><a href="http://www.iwr.uni-heidelberg.de/iwr/comopt/software/PORTA/">porta</a>,
</i>Barber
et al.'s <i><a href="http://www.geom.umn.edu/software/qhull">qhull</a></i>&nbsp;
and some visualization programs, can be found at the <a href="http://www.geom.umn.edu/">Geometry
Center</a>. A package for volume computation has been developped by Bueeler
and Enge.&nbsp; A versatile tool for the algorithmic treatment of polytopes
is Gawrilow and Joswig's&nbsp; <i><a href="http://www.math.tu-berlin.de/diskregeom/polymake/doc">polymake</a></i>
package. This high level package allows a large variety of information
about a polytope to be computed, including the entire face lattice. It
is designed to interface with a variety of vertex enumeration/convex hull
programs, including <i>cdd, lrs</i> and <i>porta</i>. <a href="http://www.cs.unb.ca/~bremner/PolytopeBase">PolytopeBase</a>
is a comprehensive annotated bibliography on the subject is maintained
by Bremner.
<p>From version 4.0, polyhedra handled by <i>lrs&nbsp;</i> need not be
full dimensional&nbsp; and may contain input linearities and redundant
columns .&nbsp; <i>lrs</i> accepts either integer or rational input, and
produces integer or rational output. All computations are done exactly
using either extended precision arithmetic or fixed long integer arithmetic.
In the latter case no overflow checking is performed, and the user is advised
to check results using the extended precision version. Since it is a pivot
based method, <i>lrs</i> can be very slow for degenerate inputs: i.e..
H-representations of non-simple polyhedra, and V-representations of non-simplicial
polyhedra. On the other hand, it does not store the vertices/ rays or facets
produced, so for very large problems it may be the only method that can
solve the problem.&nbsp; A discussion of various vertex enumeration/convex
hull methods and the types of polyhedra that cause them to behave badly
is contained in <a href="ftp://mutt.cs.mcgill.ca/pub/doc/avis/ABS96a.ps.gz">Avis,
Bremner and Seidel( 1997).</a>
<p>Additional functions of <i>lrs</i> include:
<ul>
<li>
Estimating the number of vertices/rays or facets of a polytope, and estimating
the total running time</li>

<li>
Computing the volume of a polytope given by a V-representation</li>

<li>
Solving LP problems for a polyhedron given by a H-representation</li>

<li>
Computing the Voronoi vertices and rays for an input set of data points</li>

<li>
The ability to suspend and restart execution at any time</li>
</ul>
A second program, <i>redund</i>, is supplied for removing redundancy from
and H or V-representation. In the former case, this involves the removal
of any inequalities that are not required to represent the polyhedron.
In the latter case, this is&nbsp; the problem of evaluating the extreme
points and rays of a V-representation. These problems are normally&nbsp;
considerably easier than the transforamtions performed by<i> lrs</i>. In
some cases, redundancy can greatly slow the processing time taken by <i>lrs,</i>
and it is advisble to remove any redundancy from the input file using redund
before applying <i>lrs.</i>
<p>These programs can be distributed freely under the GNU GENERAL PUBLIC
LICENSE. Please read the file COPYING carefully before using.&nbsp; Please
inform the author of any interesting applications for which <i>lrs/redund</i>
were helpful.
<h3>

<hr WIDTH="100%"><a NAME="Installation Section"></a>Installation</h3>

<ul>
<li>
Some binaries are available. From lrs home page,&nbsp; click on&nbsp; "Download"
and change directory to "binaries" and check for available platforms. These
should be usable directly, however to get source, full documentation and
a set of test files, you will need to retrieve lrslib-041 as described
below.</li>

<br>&nbsp;
<li>
From lrs home page, click on "Download" and retrieve the file lrslib-041.tar.gz</li>

<br>&nbsp;
<li>
Unpack with:</li>

<br>&nbsp;&nbsp; % gunzip lrslib-041.tar.gz
<br>&nbsp;&nbsp; % tar xvf lrslib-041.tar
<ul>&nbsp;</ul>

<li>
Go to the new directory</li>

<br>% cd lrslib-041
<br>&nbsp;
<li>
&nbsp;make binariesl <font color="#3333FF">lrs</font> and <font color="#3333FF">redund</font>&nbsp;
by typing</li>

<br>&nbsp;&nbsp; % make all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(most 32 bit unix machines)
<br>or
<br>&nbsp; % make all64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(64 bit integer machines such as DEC Alpha)
<br>or
<br>&nbsp; % make nosigs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( ansi
standard version for 32 bit machines without signals/timing routines)
<br>&nbsp;
<li>
If you have GNU MP installed you can obtain binaries <font color="#3333FF">glrs</font>
and <font color="#3333FF">gredund</font> using this library by typing</li>

<br>&nbsp; % make gmp
<br>It may be necessary to edit makefile to set the paths to the gmp library
<br>&nbsp;
<br>&nbsp;
<li>
Test the program by typing:</li>

<ul><b><font color="#000066">lrs&nbsp; cube.ine</font></b></ul>
This will convert the H-representation of a cube given cube by 6 the six
inequalities -1 &lt;= x<sub>i </sub>&lt;= 1 , i=1,2,3 given by the input:
<br><b><font color="#000099">cube</font></b>
<br><b><font color="#000099">*cube of side 2 centred at the origin</font></b>
<br><b><font color="#000099">H-representation</font></b>
<br><b><font color="#000099">begin</font></b>
<br><b><font color="#000099">6 4 rational</font></b>
<br><b><font color="#000099">1 1 0 0</font></b>
<br><b><font color="#000099">1 0 1 0</font></b>
<br><b><font color="#000099">1 0 0 1</font></b>
<br><b><font color="#000099">1 -1 0 0</font></b>
<br><b><font color="#000099">1 0 -1 0</font></b>
<br><b><font color="#000099">1 0 0 -1</font></b>
<br><b><font color="#000099">end</font></b>
<p>The output should contain (along with other comment lines beginning
with a "*")</ul>

<ul><b><font color="#FF0000">cube</font></b>
<br><b><font color="#FF0000">V-representation</font></b>
<br><b><font color="#FF0000">begin</font></b>
<br><b><font color="#FF0000">***** 4 rational</font></b>
<br><b><font color="#FF0000">&nbsp;1&nbsp; 1&nbsp; 1&nbsp; 1</font></b>
<br><b><font color="#FF0000">&nbsp;1 -1&nbsp; 1&nbsp; 1</font></b>
<br><b><font color="#FF0000">&nbsp;1&nbsp; 1 -1&nbsp; 1</font></b>
<br><b><font color="#FF0000">&nbsp;1 -1 -1&nbsp; 1</font></b>
<br><b><font color="#FF0000">&nbsp;1&nbsp; 1&nbsp; 1 -1</font></b>
<br><b><font color="#FF0000">&nbsp;1 -1&nbsp; 1 -1</font></b>
<br><b><font color="#FF0000">&nbsp;1&nbsp; 1 -1 -1</font></b>
<br><b><font color="#FF0000">&nbsp;1 -1 -1 -1</font></b>
<br><b><font color="#FF0000">end</font></b>
<p>This is a list of the 8 vertices with each co-ordinate +/- 1.&nbsp;
The ***** should be replaced by the actual number, 8, of vertices. Since
<i>lrs</i>
does not save the output produced, it does not know this value until the
execution terminates. This output is now essentially the same as file cube.ext.
To complete the test type:
<br>&nbsp;
<ul><b><font color="#000066">lrs&nbsp; cube.ext</font></b></ul>
<font color="#000000">Now the output produced is essentially the file cube.ine,
with the inequalities appearing in a different order.</font>
<p>The program buffer is a small utility that can be used to remove duplicate
line in the output that may occur if the input is not a polytope or a pointed
cone. For such unbounded polyhedra,&nbsp; rays may appear in the output
more than once. The program takes two optional integer parameters:
<ul><b><font color="#000099">buffer&nbsp; maxline maxbuffer</font></b></ul>
It builds a circular buffer of maxbuffer (default 50) lines of maxline
(default 5000)characters each. If an output line is already in the buffer,
it is not output.&nbsp; To use buffer, pipe the output from <i>lrs</i>:
<ul><b><font color="#000099">lrs&nbsp; filename | buffer</font></b></ul>
</ul>

<h3>

<hr WIDTH="100%"><a NAME="File Formats"></a>File Formats</h3>

<ul>Example files can be found in the directories ine and ext which come
in the standard distribution. File formats were developed jointly with
Komei Fukuda and are compatible with <a href="http://www.ifor.math.ethz.ch/~fukuda/cdd_home/cdd.html">cdd</a>.
The cdd manual contains additional information and examples.</ul>

<ul>The input for<i> lrs</i> is a H- or V- representation of a polytope.
These files have the following formats:
<h4>
H-representation</h4>

<hr WIDTH="100%">
<br><i>name</i>
<br><font color="#3333FF">H-representation</font>
<br>{options}
<br>{<a href="#Linearities">linearities</a>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#CC0000">
/* new in version 4.0 */</font>
<br><font color="#3333FF">begin</font>
<br><font color="#3333FF">m n rational</font>
<p>{list of inequalities }
<p><font color="#3333FF">end</font>
<br>{options}
<hr WIDTH="100%">
<br>&nbsp;
<p><i>name<u> </u></i>is a user supplied name for the polytope.&nbsp; If
the line H-representation is omitted, H-representation is assumed.&nbsp;
The input coefficients are read in free format, and are not checked for
type. Coefficients are separated by white space. Normally this file would
be saved with filename suffix .<i>ine </i>but this not required.&nbsp;
Comments may appear before the begin or after the end, and to avoid interpretation
as an option, should begin with a special character such as "*" or "#".
<br>The integer&nbsp; m is the number of inequalities,&nbsp; and the integer
n is the dimension of the input +1.
<br>A list of inequalities contains the coefficients of inequalities of
the form
<p>a<sub>0</sub> + a<sub>1 </sub>x<sub>1 </sub>+ ... + a<sub>n-1</sub>
x<sub>n-1</sub> >=&nbsp; 0.
<p>This inequality is input as the line
<p>a<sub>0 </sub>a<sub>1 </sub>... a<sub>n-1</sub>
<br>&nbsp;
<p>The coefficients can be entered as integers or rationals in the format
x/y.
<br>For example, the square centred at the origin with side length two
has inequalities
<p>1 + x<sub>1</sub> >= 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1+ x<sub>2 </sub>>=0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1-x<sub>1 </sub>>= 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1-x<sub>2 </sub>>=0
<p>and would be represented by the input file
<p><b><font color="#000099">square</font></b>
<br><b><font color="#000099">*centred square of side 2</font></b>
<br><b><font color="#000099">H-representation</font></b>
<br><b><font color="#000099">begin</font></b>
<br><b><font color="#000099">4 3 rational</font></b>
<br><b><font color="#000099">1 1 0</font></b>
<br><b><font color="#000099">1 0 1</font></b>
<br><b><font color="#000099">1 -1 0</font></b>
<br><b><font color="#000099">1 0 -1</font></b>
<br><b><font color="#000099">end</font></b>
<br>&nbsp;
<h4>
V-representation</h4>

<hr WIDTH="100%">
<br><i>name</i>
<br><font color="#3333FF">V-representation</font>
<br>{options}
<br>{<a href="#Linearities">linearities</a>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<font color="#CC0000">/* new in version 4.0 */</font>
<br><font color="#3333FF">begin</font>
<br><font color="#3333FF">m n rational</font>
<p>{list of vertices and extreme rays}
<br><font color="#3333FF">end</font>
<br>{options)
<br>
<hr WIDTH="100%">
<br><i>name<u> </u></i>is a user supplied name for the polytope.&nbsp;
The line V-representation is required.&nbsp; The input coefficients are
read in free format, and are not checked for type. Coefficients are separated
by white space. Comments may appear before the begin or after the end,
and to avoid interpretation as an option, should begin with a special character
such as "*" or "#".Normally this file would be stored with filename suffix
.<i>ext</i>, but this is not required.
<p>The integer&nbsp; m is the number of vertices and rays,&nbsp; and the
integer n is the dimension of the input +1.
<br>Each vertex is given in the form
<p>1&nbsp;&nbsp; v<sub>0&nbsp;&nbsp;</sub> v <sub>1 </sub>...&nbsp;&nbsp;
v<sub>n-1</sub>
<br>&nbsp;
<p>Each ray is given in the form
<p>0&nbsp;&nbsp; r<sub>0&nbsp;&nbsp;</sub> r <sub>1 </sub>...&nbsp;&nbsp;
r<sub>n-1</sub>
<p>where r<sub>0&nbsp;&nbsp;</sub> r <sub>1 </sub>...&nbsp;&nbsp; r<sub>n-1</sub>is
a point on the ray.
<p>There must be at least one vertex in each file. For bounded polyhedra
there will be no rays entered.
<br>The coefficients can be entered as integers or rationals in the format
x/y.
<br>For example, the unit square centred at the origin has vertices
<br>(1,1) ,(1,-1),(-1,1),(-1,-1)
<br>and would be represented by the input file
<p><b><font color="#000066">square</font></b>
<br><b><font color="#000099">*centred square of side 2</font></b>
<br><b><font color="#000066">V-representation</font></b>
<br><b><font color="#000066">begin</font></b>
<br><b><font color="#000066">4 3 rational</font></b>
<br><b><font color="#000066">1 1 1</font></b>
<br><b><font color="#000066">1 1 -1</font></b>
<br><b><font color="#000066">1 -1 1</font></b>
<br><b><font color="#000066">1 -1 -1</font></b>
<br><b><font color="#000066">end</font></b>
<p>The positive quadrant has vertex (0,0) and rays (1,0) (0,1) and is represented
<p><b><font color="#000066">quadrant</font></b>
<br><b><font color="#000099">*positive quadrant</font></b>
<br><b><font color="#000066">V-representation</font></b>
<br><b><font color="#000066">begin</font></b>
<br><b><font color="#000066">3 3 rational</font></b>
<br><b><font color="#000066">1 0 0</font></b>
<br><b><font color="#000066">0 1 0</font></b>
<br><b><font color="#000066">0 0 1</font></b>
<br><b><font color="#000066">end</font></b>
<p>Its H-representation contains the inequalities x<sub>1 </sub>>= 0 and
x<sub>2</sub> >= 0 :
<p><b><font color="#000099">quadrant</font></b>
<br><b><font color="#000099">*positive quadrant</font></b>
<br><b><font color="#000099">H-representation</font></b>
<br><b><font color="#000099">begin</font></b>
<br><b><font color="#000099">2 3 rational</font></b>
<br><b><font color="#000099">0 1 0</font></b>
<br><b><font color="#000099">0 0 1</font></b>
<br><b><font color="#000099">end</font></b>
<br>&nbsp;
<br>&nbsp;</ul>
<a NAME="Note for cdd users"></a><b>Note for cdd users</b>: <i>lrs</i>
uses essentially the same file format as <i>cdd</i>. Files prepared for
<i>cdd</i>
should work with little or no modification. Note that&nbsp; the V-representation
corresponds to the "hull" option in <i>cdd</i>. Options specific to <i>cdd</i>
can be left in the input files and will be ignored by <i>lrs</i>.&nbsp;
Note the input files for <i>lrs</i> are read in free format, after the
line <b><font color="#000099">m n rational</font></b><font color="#000000"><i>lrs</i>
will look for exactly m*n rationals or integers separated by white space
(blank,&nbsp; carriage return, tab etc.). <i>lrs</i> will not "drop" extra
columns of input if n is less than the number of columns supplied.</font>
<br>
<hr WIDTH="100%">
<h3>
<a NAME="Options"></a>Basic Options</h3>

<ul><i>lrs</i> has many options to allow various functions to be performed,
and to modify the output produced. Almost all options are placed <b>after</b>
the end statement, maintaining compatibility with <i>cdd</i>. Where this
is not the case, it will be mentioned explicitly. All options are optional.</ul>
<b><font color="#000099">allbases</font></b>
<ul>This option instructs <i>lrs</i> to list each vertex (or facet) for
each of its bases. Normally a vertex (or facet) is only output when its
lex-min basis is found, to avoid duplications - see section <a href="#Output Duplication">Output
Duplication </a><a href="#Hints and Comments">.</a> This option is often
combined with <font color="#000066">printcobasis</font>.</ul>
<b><font color="#000099">cache n</font></b>
<ul><i>lrs</i> stores the latest&nbsp; n dictionaries in the reverse search
tree. This speeds up the backtracking step, but requires more memory.&nbsp;
If n is set to one, there is no caching and "pure" reverse search is performed.&nbsp;
The default is n=10. At the end of a run a message gives cache information.
The output
<br><b><font color="#FF0000">*Dictionary Cache: max size= 4 misses= 10/1340&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Tree Depth=5</font></b>
<br>indicates that with cache size set to 4, only 10&nbsp; of the 1340
dictionaries computed were not in the cache&nbsp; during backtracking and
had to be recomputed. The maximum tree depth was 5, so there would be no
misses with a cache size of 6. Full caching reduces processing time by
about 40%.</ul>
<b><font color="#000066">debug&nbsp; startingbasis endingbasis</font></b>
<blockquote>Print out cryptic but detailed trace, dictionaries etc. starting
at #B=startingbasis and ending at #B=endingbasis. <b><font color="#000066">debug
0 0 </font></b><font color="#000000">gives a complete trace.</font></blockquote>
<b><font color="#000066">digits n&nbsp;</font>&nbsp;&nbsp;&nbsp;</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// placed before the begin statement//
<ul>n is the maximum number of decimal digits to be used. If this is exceeded
the program terminates with a message (it can&nbsp; usually be restarted).&nbsp;&nbsp;
The default is set to about 100 digits. At the end of a run a message is
given informing the user of the maximum integer size encountered. This
may be used to optimize memory usage and speed on subsequent runs (if doing
estimation for example). The output:
<br><b><font color="#FF0000">*Max digits= 45/100</font></b>
<br>indicates that the maximum integer encountered had 45 decimal digits,
and the program allowed up to 100 digit integers.</ul>
<b><font color="#000099">estimates k</font></b>
<ul>Estimate the output size. Used in conjunction with maxdepth - see <a href="#Estimation">Estimation.</a></ul>

<ul>&nbsp;</ul>
<b><font color="#000066">geometric</font>&nbsp;&nbsp;</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// H-representation&nbsp; or voronoi option only //
<ul>With this option, each ray is printed together with the vertex with
which it is incident. They output has the form:</ul>

<ul>&nbsp;&nbsp; 0&nbsp;&nbsp; r<sub>0&nbsp;&nbsp;</sub> r <sub>1 </sub>...&nbsp;&nbsp;
r<sub>n-1</sub>* 1&nbsp;&nbsp; v<sub>0&nbsp;&nbsp;</sub> v <sub>1 </sub>...&nbsp;&nbsp;
v<sub>n-1</sub></ul>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This indicates ray&nbsp; 0&nbsp;&nbsp; r<sub>0&nbsp;&nbsp;</sub> r <sub>1
</sub>...&nbsp;&nbsp;
r<sub>n-1</sub>is incident with vertex&nbsp; 1&nbsp;&nbsp; v<sub>0&nbsp;&nbsp;</sub>
v <sub>1 </sub>...&nbsp;&nbsp; v<sub>n-1</sub>.&nbsp; For the quadrant,
the output is:
<ul><b><font color="#FF0000">1 0 0</font></b>
<br><b><font color="#FF0000">0 0 1 * 1 0 0</font></b>
<br><b><font color="#FF0000">0 1 0 * 1 0 0</font></b>
<br>This indicates the origin is a vertex, and there are two geometric
rays: (0,t) and (t,0) both adjacent to the origin. For more information
see Geometric Rays in <a href="#Hints and Comments">Hints and Comments</a>.</ul>
<b><font color="#000066">incidence&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#CC0000">&nbsp;
// New in version 4.0 //</font></b>
<blockquote><font color="#000000">This option automatically switches on
</font><b><font color="#FF0000">printcobasis</font></b><font color="#000000">,
so see below for a description of this option first.</font>
<p><font color="#000000">For input H-representation, indices of all input
inequalities that contain the vertex/ray that is about to be output. For
a simplicial face, there is no new output, since these indices are already
listed. Otherwise, the additional tight inequalities are listed after a
colon. Eg:</font>
<br><b><font color="#FF0000">V#1 R#0 B#1 h=0 facets&nbsp; 12 14 15 16 :
9 10 11 13 I#8 det= 8</font></b>
<br><b><font color="#FF0000">&nbsp;1&nbsp; 0&nbsp; 0&nbsp; 0&nbsp; 1</font></b>
<br><font color="#000000">The vertex </font><b><font color="#FF0000">0
0 0 1</font></b><font color="#000000"> satisfies 8 input inequalities as
equations, as indicated by </font><b><font color="#FF0000">I#8</font></b><font color="#000000">:
those with indices </font><b><font color="#FF0000">12,14,15,16</font></b><font color="#000000">
are in the cobasis, and those with indices </font><b><font color="#FF0000">9,
10, 11, 13 </font></b><font color="#000000">are in the basis. For a ray:</font>
<br><b><font color="#FF0000">V#1 R#5 B#1 h=0 facets&nbsp; 5 9* 10 11 12
13 : 2 3 4 I#8 det= 8</font></b>
<br><b><font color="#FF0000">&nbsp;0&nbsp; 1&nbsp; 1&nbsp; 0&nbsp; 0&nbsp;
1&nbsp; 1</font></b>
<br><font color="#000000">Here the ray </font><b><font color="#FF0000">1&nbsp;
1&nbsp; 0&nbsp; 0&nbsp; 1&nbsp; 1 </font></b><font color="#000000">lies
on 8 inequalities, with indices </font><b><font color="#FF0000">5 10 11
12 13</font></b><font color="#000000"> in basis and </font><b><font color="#FF0000">2
3 4</font><font color="#000000"> i</font></b><font color="#000000">n cobasis.
The starred index</font><b><font color="#FF0000"> 9*</font></b><font color="#000000">
indicates that the ray is terminated by the input inequality 9. This inequality
is in the cobasis and defines the vertex from which the ray starts.</font>
<p><font color="#000000">For input V-representation, indices of all input
vertices/rays that lie on the facet that is about to be output:</font>
<br><b><font color="#FF0000">F#5 B#3 h=2 vertices/rays&nbsp; 7 8* 11 13
15 : 1 3 5 9 I#8 det= 16</font></b>
<br><b><font color="#FF0000">1 -1&nbsp; 0&nbsp; 0&nbsp; 0</font></b>
<br><font color="#000000">The facet generated by inequality x<sub>1</sub>
&lt;= 1 contains 8 input vertices, as indicated by I#8: those with indices
</font><b><font color="#FF0000">7,11,13,15</font></b><font color="#000000">
are in the cobasis, and those with indices</font><b><font color="#FF0000">
1 3 5 9 </font></b><font color="#000000">are in the basis.The starred index</font><b><font color="#FF0000">
8*</font></b><font color="#000000"> indicates that this vertex&nbsp; is
also in the cobasis, but is not contained in the facet. It arises due to
the lifting operation used with input V-representations.</font></blockquote>
<b><font color="#000099">#incidence</font></b>
<blockquote><font color="#000000">The same as printcobasis. Included for
compatability with <i>cdd.</i></font></blockquote>
<b><font color="#000066">linearity&nbsp; k&nbsp; i<sub>1 </sub>i<sub>2
</sub>i
... i<sub>k</sub></font></b>
<blockquote>The input contains k linearities in rows <b><font color="#000066">i<sub>1
</sub>i<sub>2
</sub>i
... i<sub>k </sub></font></b>of the input file are equations. See
<a href="#Linearities">Linearities.</a></blockquote>
<b><font color="#000066">maxdepth k</font></b>
<ul><font color="#000000">The search will be truncated at depth k. All
bases with depth less than or equal to k will be computed.&nbsp; k is&nbsp;
a non-negative integer, and this option is used for estimates - see <a href="#Estimation">Estimation.</a></font>
<br><font color="#000000"><b>Note</b>: For H-representations, rays at depth
k will not be reported. For V-representations, facets at depth k will not
be reported.</font></ul>
<b><font color="#000099">maximize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></b>
// H-representation&nbsp; only //
<br><b><font color="#000099">minimize</font></b>
<ul><font color="#000000">See <a href="#Linear Programming">Linear Programming.</a></font></ul>
<font color="#000066">&nbsp;<b>mindepth k</b></font>
<ul><font color="#000066">&nbsp;</font><font color="#000000">Backtracking
will be terminated at depth k, for k a non-negative integer. This can be
used for running reverse search on subtrees as separate processes, e.g.
in a distributed computing environment.</font></ul>
<b><font color="#000066">nonnegative&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font><font color="#990000">//modified in lrs 4.1 //&nbsp;&nbsp;&nbsp;</font><font color="#000066">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></b><font color="#CC0000">
// This option must come before the begin statement//</font>
<br><font color="#CC0000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//H-representation only //</font>
<br>&nbsp;
<blockquote><font color="#000000">For problems where the input is an H-representation
of the form b+Ax>=0, x>=0 (ie. all variables non-negative, all constraints
inequalities) it is not necessary to give the non-negative constraints
explicitly if the </font><font color="#000099">nonnegative</font><font color="#000000">
option is used. This option cannot be used for V-representations, or with
the </font><font color="#000099">linearit</font><font color="#000000">y
option (in which case the linearities will be treated as inequalities).
This option may be used with </font><font color="#000099">redund</font><font color="#000000">,
but the implied nonnegativity constraints are not tested themselves for
redundancy. To test everything it is necessary to enter the nonnegativity
constraints explicitly in the input file.</font></blockquote>

<p><br><b><font color="#000066">printcobasis&nbsp; k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

</font></b><font color="#CC0000">Modified in lrs4.0</font>
<ul>Every k'th cobasis is printed. <font color="#990000">If k is omitted,
the cobasis is printed for each vertex/ray/facet that is output</font>.
For a long run it is useful to print the cobasis occasionally so that the
program can be restarted if necessary.
<br><b>H-representation:&nbsp; </b><font color="#000000">If</font> the
input is an H-representation the cobasis is a list the indices of the inequalities
from the input file that define the current vertex or ray. For example,
with input cube.ine a typical output is:
<br><b><font color="#FF0000">V#5 R#0 B#5 h=1 facets&nbsp; 3 4 5 I#3 det=1</font></b>
<br><b><font color="#FF0000">1 1 1 -1</font></b>
<br><font color="#000000">This indicates that the vertex (1,1,-1) is defined
by the 3rd, 4th and 5th facet inequalities in the input file being satisfied
as equations. It is the (B#)5th</font> <font color="#000000">basis computed,
and there have been (V#)5 vertices and (R#)0 rays output up to this point.
I#3 means that this vertex is incident with 3 input inequalities, ie. it
is non-degenerate. See option&nbsp; </font><b><font color="#000099">incidence</font></b><font color="#000000">
above for more information.</font>
<br><font color="#000000">For rays, a cobasis is also printed. In this
case the cobasis is the cobasis of the vertex from which the ray emanates.
One of the indices is starred, this indicates the inequality to be dropped
from the cobasis to define the ray. For example the output:</font>
<br><b><font color="#FF0000">V#1 R#6 B#4 h=1 facets&nbsp; 2 4* 5 7 I#3
det=1</font></b>
<br><b><font color="#FF0000">0 1 1 2 1</font></b>
<br><font color="#000000">indicates that the ray (1,1,2,1) emanates from
a vertex with cobasis defined by input inequalities 2 4 5 7 satisfied as
equations. The ray is defined by dropping the equation with index 4. Note
that there may not appear any vertex in the output with cobasis 2 4 5 7,
since the corresponding vertex may be degenerate and printed with another
(the lex-min) cobasis. To find out which vertices correspond to which rays,
use also the </font><b><font color="#000099">geometric </font></b><font color="#000000">option.&nbsp;
Now the output may appear:</font>
<br><b><font color="#FF0000">V#1 R#6 B#4 h=1 facets&nbsp; 2 4* 5 7 I#3
det=1</font></b>
<br><b><font color="#FF0000">0 1 1 2 1&nbsp; * 1 0 0 0 0</font></b>
<br><font color="#000000">This indicates that the ray is incident to the
origin. Alternatively, if the </font><b><font color="#000099">allbases
</font></b><font color="#000000">option
is used, all cobases will be printed out.</font>
<br><b>V-representation</b>: If the input is a V-representation, the cobasis
is a list of the input vertices /rays that define the current facet. For
example, with input file cube.ext a typical output is:
<br><b><font color="#FF0000">F#5 B#4 h=3 vertices/rays&nbsp; 2 3 4 5* I#3
det= 8</font></b>
<br><b><font color="#FF0000">&nbsp;1&nbsp; 0&nbsp; 0 -1</font></b>
<br><font color="#000000">There have been 5 facets output up to this point,
and 4 bases have been computed. This facet is defined by the vertices in
positions 2,3,4 in the input file. The additional cobasis index 5* appears
because a V-representation is lifted to one higher dimension before processing,
and this index fills out the cobasis. I#3 means that this facet is incident
with 3 input vertices/rays, ie. it is non-degenerate. See option </font><b><font color="#000099">incidence</font></b><font color="#000000">
above for more information.</font>
<br><font color="#000000">To initiate <i>lrs</i> from this facet all 4
indices must be given in this order (omit the *), eg.</font>
<br><font color="#000099">startingcobasis 2 3 4 5</font>
<br><font color="#000000">Similarly, all 4 indices must be given in order
to restart from this facet:</font>
<br><font color="#000099">restart 5 4 3 2 3 4 5</font></ul>
<font color="#000066"><b>restart&nbsp; V# R# B# depth {facet #s or vertex/ray
#s</b>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

</font><font color="#990000">Modified in lrs4.0</font>
<ul><font color="#000000"><i>lrs</i> can be restarted from any known cobasis.
The calculation will proceed to normal termination. All of the information
is contained in the output from a </font><b><font color="#000099">printcobasis</font></b><font color="#000000">
option.&nbsp; The <b>order of the indices is very important,</b> enter
them exactly as they appear in the output from the previously aborted run.
To restart from cobasis:</font></ul>

<ul><b><font color="#FF0000">V#5 R#0 B#5 h=1 facets&nbsp; 3 4 5 det=1</font></b>
<br><font color="#000000">enter:</font>
<br><b><font color="#000066">restart 5 0 5 1 3 4 5</font></b>
<p><b><font color="#FF0000">F#5 B#4 h=3 vertices/rays&nbsp; 2 3 4 5* det=
8</font></b>
<br><b><font color="#FF0000">&nbsp;1&nbsp; 0&nbsp; 0 -1</font></b>
<br><font color="#000000">enter</font>
<br><b><font color="#000066">restart 5 4 3 2 3 4 5</font></b>
<p><font color="#000000">Note that if some cobasic index is followed by
a "*",&nbsp; then the index only, without the "*", is included in the restart
line.</font>
<br><b><font color="#FF0000">Caution: </font></b><font color="#000000">When
restarting, output from the restart dictionary may be duplicated, and the
final totals of number of vertices/rays/facets may reflect this.</font></ul>
<b><font color="#000066">startingcobasis i<sub>1 </sub>i<sub>2 </sub>i
... i<sub>n-1</sub></font></b>
<ul><font color="#000000">This allows the user to specify a known cobasis
for beginning the reverse search. </font><b><font color="#000066">i<sub>1
</sub>i<sub>2
</sub>i
... i<sub>n-1</sub></font><sub> </sub></b><font color="#000000">is a list
of the inequalities (for H-representation) or vertices/rays (for V-representation)
that define a cobasis. If it is invalid, or this option is not specified,
<i>lrs</i>
will find its own starting cobasis. For example, with cube.ine, the user
can start at vertex (-1,1,-1) by specifying:</font>
<br><b><font color="#000099">startingcobasis 1 3 4</font></b></ul>
<b><font color="#000099">truncate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></b><font color="#000000">
// H-representation only //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font><b><font color="#CC0000">New!</font></b>
<blockquote><font color="#000000">The reverse search tree is truncated(pruned)&nbsp;
whenever a new vertex is encountered. </font><font color="#CC0000">Note</font><font color="#000000">:
This does note necessarily produce the set of all vertices adjacent to
the optimum vertex in the polyhedron, but just a subset of them.</font></blockquote>
<b><font color="#000066">verbose</font></b>
<blockquote><font color="#000000">Print slightly more detailed information
about the run.</font></blockquote>
<b><font color="#000099">volume&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></b>
// V-representation&nbsp; only //
<ul>Compute volume - see section <a href="#Volume Computation">Volume Computation.</a></ul>
<b><font color="#000099">voronoi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></b>
// V-representation&nbsp; only - <font color="#990000">place immediately
after end statement </font>//
<ul><font color="#000000">Compute Voronoi diagram - see section <a href="#Voronoi Diagrams">Voronoi
Diagrams.</a></font></ul>

<h3>

<hr WIDTH="100%"></h3>

<h3>
<a NAME="Arithmetic Packages"></a>Arithmetic Packages&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(new in Version 4.0)</h3>
Version 4.0 comes with a choice of arithmetic packages. Currently available
are:
<p>&nbsp;&nbsp;<font color="#3333FF"> lrsmp</font>&nbsp;&nbsp;&nbsp;&nbsp;
Extended precision arithmetic used in previous releases
<p>&nbsp;&nbsp;<font color="#3333FF"> lrslong</font>&nbsp;&nbsp; Fixed
length long integer arithmetic. No overflow checking
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
but 5-10 times faster than lrsmp.
<p>&nbsp;&nbsp; <font color="#3333FF">lrsgmp</font>&nbsp;&nbsp; An interface
to GNU MP&nbsp; which must be installed first.
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Runs 1-6 times faster than lrsmp on typical problems.
<p>&nbsp; The standard make gives binaries&nbsp;<i> lrs/redund</i> with
<font color="#3333FF">lrsmp</font>,
and<i> lrs1/redund1</i> with <font color="#3333FF">lrslong</font>. The
fixed integer package is particularly useful with 64 bit machines, and
fairly large combinatorial problems (15-20 dimensions) have been correctly
solved. It may be useful for doing empirical work, eg. searching for polyhedra
with certain properties. Final results should always be checked using<font color="#3333FF">
lrsmp</font>. If you have GNU MP installed, "make gmp" will produce binaries
<i>glrs/gredund
</i>using
this library. It may be necessary to edit the makefile to specify the path
to gmp.
<br>&nbsp;
<h3>

<hr WIDTH="100%"><a NAME="Estimation"></a>Estimation</h3>

<ul>The estimation feature of <i>lrs</i> allows estimates to be made of
the output size and running time. These are based on Knuth's technique
for estimating the size of backtracking trees, and are described in <a href="ftp://mutt.cs.mcgill.ca/pub/doc/avis/AD94a.ps.gz">Avis
and Devroye(1994).</a>&nbsp; The estimate is unbiased, that is the expected
value of the estimate is the actual value. To get an estimate use the <font color="#000099">maxdepth</font>
option to limit the search depth, and the <b><font color="#000099">estimates</font></b>option:</ul>
<b><font color="#000066">maxdepth d</font></b>
<br><b><font color="#000066">estimates k</font></b>
<ul>This will cause <i>lrs</i> to perform k random probes from each&nbsp;
node of the tree at depth d. k should be at least 1 and d at least zero.
<p><b>H-representation: </b>If the input is an H-representation, the program
gives an unbiased estimate of the number of vertices and&nbsp; rays in
the V-representation,&nbsp; and the total number of bases that will be
computed by <i>lrs. </i>For the H-representation <i>cube.ine</i>, the options
<b><font color="#000099">maxdepth
1 </font></b>and <b><font color="#000099">estimates 1</font></b> produce
the output:
<br><font color="#FF0000">*<b>Estimates: vertices=9&nbsp;&nbsp;&nbsp; rays=0&nbsp;&nbsp;&nbsp;
bases=9</b></font>
<br><b><font color="#FF0000">*Total number of tree nodes evaluated: 6</font></b>
<br>In this case the V-representation of the cube is estimated to have
9 vertices, and it is estimated that <i>lrs</i> will compute a total of
9 bases. The estimate was based on evaluating 6 tree nodes.&nbsp; <b>Note</b>:
The estimate for the number of rays may be an overestimate if the polyhedron
is not a cone, since some rays may be duplicated in the output - see subsection
<a href="#Output Duplication">Output
Duplication.</a>
<p><b><font color="#000000">V-representation:</font></b> If the input is
a V-representation, the program gives an unbiased estimate of the number
of facets in the H-representation, and the total number of bases that <i>lrs</i>
will compute.&nbsp; For V-representation <i>cube.ext,</i> the options <b><font color="#000099">maxdepth
0 </font></b>and <b><font color="#000099">estimates 3 </font></b>produce
the output:
<br><b><font color="#FF0000">*Estimates:&nbsp; facets=7&nbsp; bases=8</font></b>
<br><b><font color="#FF0000">*Total number of tree nodes evaluated: 7</font></b>
<br>In this cases it is estimated that the H-representation of the cube
will contain 7 facets, and it is estimated that&nbsp; <i>lrs</i> will compute
a total of 7 bases to find it. The estimate was formed by evaluating 7
tree nodes. <b>Note</b>: The number of facets estimated may be an overestimate
if the polyhedron is not bounded - see subsection <a href="#Output Duplication">Output
Duplication.</a>
<p><b>Voronoi diagrams: </b>Estimates for the number of Voronoi vertices
and Voronoi rays for a V-representation of a set of data points may be
obtained by combining the <b><font color="#000099">voronoi, estimates</font></b>
and <b><font color="#000099">maxdepth </font></b>options.
<p><b>Repeated estimates:</b> In order to get estimates with different
random probes, <i>lrs</i> can be given a seed for the random number generator.
There are two ways: an option and a command line argument.</ul>
<b><font color="#000066">seed n</font></b>
<ul><font color="#000000">The integer n is used as a seed for the random
number generator.</font>
<p>The command line argument is an integer n which will be the seed and
overrides a seed given as an option.</ul>
<b><font color="#000066">lrs n &lt; filename</font></b>
<br>&nbsp;
<ul><b>Using the estimator: </b>The running time of <i>lrs</i> is proportional
to the number of bases, so an estimate of the number of bases gives an
easy way to estimate the running time for solving the complete problem
by <i>lrs</i>. For the case of polytopes that contain the origin, a V-representation
can be processed as an H-representation and vice-versa (this is an application
of duality). Hence facet estimates for a V-representation can also be obtained
by running the problem as an H-representation with the estimates option.
The estimated number of vertices will be in this case be an unbiased estimate
for the number of facets for the original problem. So running the estimator
on the file cube.ext with the header set as H-representation , <b><font color="#000099">maxdepth
0 </font></b>and <b><font color="#000099">estimates 3, </font></b>we get
the output:
<br>&nbsp;*<b><font color="#FF0000">Estimates: vertices=5&nbsp;&nbsp;&nbsp;
rays=0&nbsp;&nbsp;&nbsp; bases=9</font></b>
<br><b><font color="#FF0000">*Total number of tree nodes evaluated: 8</font></b>
<br><font color="#000000">Since the origin is an interior point, the estimated
number of vertices is an accurate estimate of the number of facets of the
H-representation of the cube.&nbsp;&nbsp; Similarly, estimates for an input&nbsp;
H-representation of a polytope containing the origin may be obtained by
processing the file as a V-representation. The output will be essentially
the same, but the number of bases computed may be very different, see the
subsection <a href="#H- vs V- representation">H- vs V-representation.</a></font>&nbsp;
For a large problem of this type, it is useful to get estimates for the
number of bases that <i>lrs</i> will compute for both V- and H-representations,
so that simpler problem can be chosen.
<p>The estimates may also be used to judge the feasibility of solving the
problem using other codes. For example, any code that uses triangulation/perturbation
to resolve degeneracy will have trouble if the number of bases is huge.
Codes which must store all the output in memory (currently all codes except
reverse search methods such as <i>lrs</i>) will have trouble if the estimated
output size is huge.</ul>

<hr WIDTH="100%">
<h3>
&nbsp;<a NAME="Linear Programming"></a>Linear Programming</h3>

<ul><i>lrs</i> can be used to solve linear programming problems in rational
arithmetic when the input is an H-representation.&nbsp; Use the option:</ul>
<b><font color="#000066">lponly</font></b>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
and one of the options maximize or minize:
<p><b><font color="#000066">maximize </font><font color="#000099">a<sub>0</sub>
a<sub>1 </sub>... a<sub>n-1</sub></font></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// H-representation&nbsp; only //
<ul>&nbsp;simply maximizes the function&nbsp; a<sub>0</sub> + a<sub>1 </sub>x<sub>1
</sub>+
... + a<sub>n-1</sub> x<sub>n-1</sub>
<br>&nbsp;over the given polyhedron. A optimal vertex is given when it
exists, otherwise for unbounded solutions a vertex and ray is given. A
minimization will be performed if the&nbsp; following option is specified:</ul>
<b><font color="#000066">minimize </font><font color="#000099">a<sub>0</sub>
a<sub>1 </sub>... a<sub>n-1</sub></font></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// H-representation&nbsp; only //
<p>To print the dictionary at a few key points also include the option:
<p><b><font color="#000066">verbose</font></b>
<p>
<hr WIDTH="100%">
<ul>&nbsp;</ul>

<h3>
<a NAME="Volume Computation"></a>Volume Computation</h3>
<i>lrs</i> can be used to compute the volume of a polytope given as a V-representation.
The option
<p><b><font color="#000099">volume&nbsp;</font>&nbsp;&nbsp;&nbsp;</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// V-representation only //
<p>will cause the volume to be computed. For input cube.ext, the output
is:
<br><b><font color="#FF0000">*Volume=8</font></b>
<br>If the <font color="#000099"><b>volume</b> </font>option is applied
to an H-representation, the results are not predictable.
<p>For polytopes given by a H-representation, it will first be necessary
to compute the V-representation. Alternatively the program <i><a href="http://wwwjn.inf.ethz.ch/ambros/pd.html">pd&nbsp;</a></i>
may be used, which works directly with the H-representation.
<br>
<hr WIDTH="100%"><a NAME="Voronoi Diagrams"></a>
<h3>
Voronoi Diagrams</h3>
<i>lrs</i> can be used the compute the V-vertices of a Voronoi diagram
of a set of data points in n-1 dimensional space. To do this we use a standard
lifting procedure (see, e.g., Edelsbrunner, "Algorithms in Combinatorial
Geometry," pp 296-297) . Each point is mapped to a half space tangent to
the parabaloid in n dimensions, by the mapping:
<p>p<sub>1&nbsp;</sub> , p<sub>2&nbsp;</sub> , ...., p<sub>n-1</sub>&nbsp;&nbsp;&nbsp;&nbsp;
->&nbsp;&nbsp;&nbsp; (p<sub>1 </sub><sup>2&nbsp; </sup>+&nbsp;&nbsp; p<sub>2</sub><sup>2
</sup>+&nbsp;
...&nbsp;&nbsp; +&nbsp; p<sub>n-1</sub><sup>2&nbsp;</sup> ) - 2 p<sub>1</sub>&nbsp;
x<sub>1&nbsp;</sub> - 2 p<sub>2&nbsp;</sub> x<sub>2
</sub>- .... - 2&nbsp;
p<sub>n-1 </sub>x<sub>n -1&nbsp;</sub> + x <sub>n</sub>>= 0
<p><i>lrs</i> is applied to the H-representation so created.&nbsp; This
transformation is performed automatically for a V-representation if the
<p><b><font color="#000099">voronoi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</font></b>// V-representation only - <font color="#990000">place immediately
after end statement</font> //
<p>option is specified.
<br><b>Note</b>: The input file must consist entirely of data points (no
rays), i.e.. there must be a one in column one of each line. The <b><font color="#000099">volume
</font></b>option
should not be used, since the volume reported will not be the volume of
the original V-representation.
<br>The output will consist of the Voronoi vertices (columns beginning
with a one) and Voronoi rays (columns beginning with zero) for the Voronoi
diagram defined on the data points.&nbsp; If the <b><font color="#000099">printcobasis</font></b>
option is given, the n "<b><font color="#FF0000">data points</font></b>"
indices produced will tell which set of input data points corresponds to
the given Voronoi vertex or ray. In case of degeneracies, a given Voronoi
vertex may be generated by more than n of the input data points. In this
case, use of the <b><font color="#000099">allbases</font></b> option will
cause all&nbsp; sets of n input data points corresponding to a Voronoi
vertex to be printed. For Voronoi rays, the immediately preceding&nbsp;
cobasis is the cobasis of the the Voronoi vertex from which the ray emanates.&nbsp;
The index followed by a <b><font color="#FF0000">* </font></b><font color="#000000">is</font>the
data point to drop in order to generate the ray. If the
<b><font color="#000099">geometric
</font></b>option
is given the correspondence between Voronoi rays and Voronoi vertices will
be produced automatically.
<p><b><font color="#000000">Example:</font></b> Compute the Voronoi diagram
of the planar point set (0,0), (2,1), (1,2), (0,4), (4,0), (4,4) (2,-4).
<br><b><font color="#000099">vor7-3</font></b>
<br><b><font color="#000099">*6 Voronoi vertices and 5 rays</font></b>
<br><b><font color="#000099">*7 input data points</font></b>
<br><b><font color="#000099">V-representation</font></b>
<br><b><font color="#000099">begin</font></b>
<br><b><font color="#000099">7 3 integer</font></b>
<br><b><font color="#000099">1 0 0</font></b>
<br><b><font color="#000099">1 2 1</font></b>
<br><b><font color="#000099">1 1 2</font></b>
<br><b><font color="#000099">1 0 4</font></b>
<br><b><font color="#000099">1 4 0</font></b>
<br><b><font color="#000099">1 4 4</font></b>
<br><b><font color="#000099">1 2 -4</font></b>
<br><b><font color="#000099">end</font></b>
<br><b><font color="#000099">voronoi</font></b>
<br><b><font color="#000099">printcobasis</font></b>
<br><b><font color="#000099">allbases</font></b>
<br><b><font color="#000099">geometric</font></b>
<p><font color="#000000">The output produced is</font>
<br>&nbsp;
<p><b><font color="#FF0000">V-representation</font></b>
<br><b><font color="#FF0000">begin</font></b>
<br><b><font color="#FF0000">***** 3 rational</font></b>
<br><b><font color="#FF0000">V#1 R#0 B#1 h=0 data points&nbsp; 1 5 7 det=64</font></b>
<br><b><font color="#FF0000">1 2 -3/2</font></b>
<br><b><font color="#FF0000">V#1 R#1 B#1 h=0 data points&nbsp; 1 5* 7 det=64</font></b>
<br><b><font color="#FF0000">0 -2 -1&nbsp; * 1 2 -3/2</font></b>
<br><b><font color="#FF0000">V#1 R#2 B#1 h=0 data points&nbsp; 1* 5 7 det=64</font></b>
<br><b><font color="#FF0000">0 2 -1&nbsp; * 1 2 -3/2</font></b>
<br><b><font color="#FF0000">V#1 R#2 B#2 h=1 data points&nbsp; 1 2 5 det=16</font></b>
<br><b><font color="#FF0000">1 2 -3/2</font></b>
<br><b><font color="#FF0000">V#2 R#2 B#3 h=2 data points&nbsp; 1 2 3 det=12</font></b>
<br><b><font color="#FF0000">1 5/6 5/6</font></b>
<br><b><font color="#FF0000">V#3 R#2 B#4 h=3 data points&nbsp; 1 3 4 det=16</font></b>
<br><b><font color="#FF0000">1 -3/2 2</font></b>
<br><b><font color="#FF0000">V#3 R#3 B#4 h=3 data points&nbsp; 1 3* 4 det=16</font></b>
<br><b><font color="#FF0000">0 -1 0&nbsp; * 1 -3/2 2</font></b>
<br><b><font color="#FF0000">V#4 R#3 B#5 h=2 data points&nbsp; 2 5 6 det=32</font></b>
<br><b><font color="#FF0000">1 15/4 2</font></b>
<br><b><font color="#FF0000">V#4 R#4 B#5 h=2 data points&nbsp; 2* 5 6 det=32</font></b>
<br><b><font color="#FF0000">0 1 0&nbsp; * 1 15/4 2</font></b>
<br><b><font color="#FF0000">V#5 R#4 B#6 h=3 data points&nbsp; 2 3 6 det=20</font></b>
<br><b><font color="#FF0000">1 27/10 27/10</font></b>
<br><b><font color="#FF0000">V#6 R#4 B#7 h=4 data points&nbsp; 3 4 6 det=32</font></b>
<br><b><font color="#FF0000">1 2 15/4</font></b>
<br><b><font color="#FF0000">V#6 R#5 B#7 h=4 data points&nbsp; 3* 4 6 det=32</font></b>
<br><b><font color="#FF0000">0 0 1&nbsp; * 1 2 15/4</font></b>
<br><b><font color="#FF0000">end</font></b>
<p><font color="#000000">The output contains 6 Voronoi vertices :</font>
<br><font color="#000000">(2, -3/2), (5/6,5/6),(-3/2,2),(15/4,2), (27/10,27/10),
(2,15/4).</font>
<br><font color="#000000">The Voronoi vertex (2,-3/2) appears twice in
the output with data point indices 1 5 7 and 1 2 5. This means that it
is degenerate and is defined by the set of 4 input data point in positions
1,2,5,7 in the input file. I.e.. it is the centre of an empty&nbsp; circle
through the four input data points </font>(0,0), (2,1), 4,0), (2,-4).&nbsp;
The other Voronoi vertices appear once each and are defined respectively
by the data points <font color="#000000">with indices (i.e..&nbsp; position
in the input file)&nbsp; 1 2 3,&nbsp; 1 3 4,&nbsp; 2 5 6,&nbsp; 2 3 6 and
3 4 6. The&nbsp; Voronoi diagram has 5 rays</font>
<br><font color="#000000">(2, -3/2) + (-2t,-t),&nbsp;&nbsp;&nbsp; (2,-3/2)+(2t,-t),&nbsp;&nbsp;&nbsp;
(-3/2,2)+(-t,0),&nbsp;&nbsp;&nbsp; (15/4,2)+(t,0),&nbsp;&nbsp;&nbsp; (2,15/4)+(0,t)</font>
<p><font color="#000000">For example, the first ray in the output appears:</font>
<br><b><font color="#FF0000">V#1 R#1 B#1 h=0 data points&nbsp; 1 5* 7 det=64</font></b>
<br><b><font color="#FF0000">0 -2 -1&nbsp; * 1 2 -3/2</font></b>
<br><font color="#000000">&nbsp;This means that the ray (-2t,-t) emanates
from the vertex defined by data points 1 5 7, namely (2, -3/2). The asterisk
on index 5 indicates that the ray is defined by the data points with indices
5 and 7, namely (0,0) and (2,-4).</font>
<br>&nbsp;
<br>&nbsp;
<h3>

<hr WIDTH="100%">&nbsp;<a NAME="Extreme Point Enumeration and Redundant Inequalities"></a>Extreme
Point Enumeration and Redundant Inequalities</h3>
A convex hull problem that occurs frequently is to enumerate the extreme
points (vertices) of a given set of input points. This problem is in fact
much simpler than the problem of finding the facets of the given input
point set. It can be solved by linear programming.&nbsp; The dual problem
is to remove redundant inequalities from an H-representation. An input&nbsp;
inequality is redundant if it can be deleted without changing the polyhedron.
The program <i>redund </i>also solves these problems. They can be solved
by
<i>cdd
</i>using the vertex_listing&nbsp; and facet_listing&nbsp; options.
<p>To remove input points that are not vertices from a V-representation
or redundant inequalities from an H-representation use the command:
<ul><b><font color="#000099">redund filename</font></b></ul>
<font color="#000000">The resulting file can be used directly with lrs,
or even piped into lrs. In fact, lrs works best if the input is non-redundant,
see the section <a href="#Hints and Comments">Redundancy vs Degeneracy.</a></font>
<p>Note: Versions of redund prior to this release failed to remove redundancy
from the starting basis.
<hr WIDTH="100%">
<h2>
<a NAME="Linearities"></a>Linearities&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(New in Version 4.0)</h2>

<p><br><b><font color="#000066">linearity&nbsp; k&nbsp; i<sub>1 </sub>i<sub>2
</sub>i
... i<sub>k</sub></font></b>
<blockquote>The input file contains k linearities. If the input is a H-representation,
the rows <b><font color="#000066">i<sub>1 </sub>i<sub>2 </sub>i ... i<sub>k
</sub></font></b>of
the input file are equations. For a V-representation, the rows with these
indices should begin with zero in column one, and will be interpreted as
lines rather than rays.&nbsp; Linearities defined on the input vertices
of a V-representation are not defined, but the program will accept them
and produce some output. Each of the indice <b><font color="#000099">i<sub>k</sub></font></b>
must be a distinct number between <b><font color="#000099">1</font></b>
and <b><font color="#000099">m</font></b>. With an&nbsp; H-representation,
linearities are useful for enumeration of vertices on a facet or lower
dimensional subspace. For example the file:
<p><b><font color="#000099">cube_ridge</font></b>
<br><b><font color="#000099">*cube of side 2 centred at the origin</font></b>
<br><b><font color="#000099">H-representation</font></b>
<br><b><font color="#000099">linearity 2&nbsp; 1 5</font></b>
<br><b><font color="#000099">begin</font></b>
<br><b><font color="#000099">6 4 rational</font></b>
<br><b><font color="#000099">1 1 0 0</font></b>
<br><b><font color="#000099">1 0 1 0</font></b>
<br><b><font color="#000099">1 0 0 1</font></b>
<br><b><font color="#000099">1 -1 0 0</font></b>
<br><b><font color="#000099">1 0 -1 0</font></b>
<br><b><font color="#000099">1 0 0 -1</font></b>
<br><b><font color="#000099">end</font></b>
<p><font color="#000000">causes vertices to be enumerated on the ridge
which is the intersection of the two facets</font>
<p><font color="#000000">x<sub>1</sub> = -1&nbsp;&nbsp; and&nbsp;&nbsp;
x<sub>2</sub> = 1</font>
<p><font color="#000000">so the output is the pair of vertices</font>
<p><font color="#CC0000">cube_ridge</font>
<br><font color="#CC0000">*Input linearity in row(s) 1 5</font>
<br><font color="#CC0000">V-representation</font>
<br><font color="#CC0000">begin</font>
<br><font color="#CC0000">2&nbsp; 4&nbsp; rational</font>
<br><font color="#CC0000">&nbsp;1 -1&nbsp; 1&nbsp; 1</font>
<br><font color="#CC0000">&nbsp;1 -1&nbsp; 1 -1</font>
<br><font color="#CC0000">end</font>
<p>Specifying linearities in this way will often produce <a href="#Extreme Point Enumeration and Redundant Inequalities">redundancy</a>,
especially if the dimension of the problem is reduced considerably. As
a preprocessing step, it is useful to apply to remove any redundancy by
<i>redund</i>.
In the case of the above problem the output produced by<i> redund</i> is:
<p><font color="#CC0000">cube</font>
<br><font color="#CC0000">*Input linearity in row(s) 1 5</font>
<br><font color="#CC0000">*row 2 was redundant and removed</font>
<br><font color="#CC0000">*row 4 was redundant and removed</font>
<br><font color="#CC0000">H-representation</font>
<br><font color="#CC0000">linearity 2 1 2</font>
<br><font color="#CC0000">begin</font>
<br><font color="#CC0000">4 4 rational</font>
<br><font color="#CC0000">&nbsp;1&nbsp; 1&nbsp; 0&nbsp; 0</font>
<br><font color="#CC0000">&nbsp;1&nbsp; 0 -1&nbsp; 0</font>
<br><font color="#CC0000">&nbsp;1&nbsp; 0&nbsp; 0&nbsp; 1</font>
<br><font color="#CC0000">&nbsp;1&nbsp; 0&nbsp; 0 -1</font>
<p><font color="#000000">and two redundant halfspaces were removed.</font>
<p><font color="#000000">Redundant columns are closely related to linearities.
If we examine the V-representation of cube_ridge above we can see that
it is just a line segment in 3 dimensional space. Further,&nbsp; columns
2 and 3 are multiples of column 1. If lrs is applied to this file, the
column redundancies give rise to two linearities, so the output will appear
as the H-representation given above: geometrically the intersection of
two planes (the linearities) with two half-planes (defining the endpoints
of the line segment).</font>
<p><font color="#000000">In general, the representation of the linearity
space is not unique, however the one produced by lrs should be the same
as that produced by cdd.</font></blockquote>

<p><br>
<hr WIDTH="100%">
<h3>
<a NAME="Timing and Interrupts"></a>Timing and Interrupts</h3>
<i>lrs</i> handles certain signals unless it is compiled with the -DOMIT_SIGNALS
option. It is possible to interrupt <i>lrs</i> and get the latest cobasis,
which can be used for restarting the program (useful if the machine is
going down!)
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>signal&nbsp;</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<b>operation</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USR1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
print current cobasis and continue
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TERM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
print current cobasis and terminate
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INT (ctrl-C)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ditto
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HUP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ditto
<br><i>lrs</i> also provides timing information, unless compiled with the
option -DOMIT_TIMES.
<br>
<hr WIDTH="100%">
<h3>
<a NAME="Error Messages"></a>Error Messages and Troubleshooting</h3>
The most common error occurs from an incorrect input file specification,
please check the section <a href="#File Formats">File Formats </a>carefully.
In particular, <i>lrs</i> does not check the type or number of input coefficients
specified.&nbsp; After the line
<br><b><font color="#000099">m n rational</font></b>
<br><font color="#000000">you must specify <b>exactly</b> m*n rational
or integer coefficients. They are read&nbsp; in <b>free format</b>, but
normally each input facet or vertex/ray is begun on a new line.&nbsp; See
<a href="#Note for cdd users">note
for cdd users.</a></font>
<p>The following error messages are produced by <i>lrs</i>. They are&nbsp;
arranged in alphabetic order.
<p><b><font color="#FF0000">Data type must be integer of rational</font></b>
<ul><font color="#000000"><i>lrs</i> does not handle floating point data,
change to integer or rational input.</font></ul>
<b><font color="#FF0000">Digits must be at most 2295&nbsp; Change MAX_DIGITS
and recompile</font></b>
<ul><font color="#000000">The digits option was specified, but the number
of&nbsp; decimal digits is too large (the values shown here is for 64 bit
machines). MAX_DIGITS&nbsp; (default 255) is the maximum number of array
locations used for extended precision arithmetic. This value should be
increased&nbsp; and <i>lrs</i> recompiled.</font></ul>
<b><font color="#FF0000">Input Polyhedron does not have full dimension</font></b>
<br><b><font color="#FF0000">If input is a cone, change to H-representation,
or add the origin 1 0 0 ... 0</font></b>
<ul><font color="#000000">The input polyhedron does not have dimension
n-1. Either there is a mistake in the input, or it must be projected onto
a full dimensional subspace. <i><a href="http://www.ifor.math.ethz.ch/staff/fukuda/cdd_home/cdd.html">cdd</a></i>
has a function for doing this. The second message only appears for V-representations
- note that at least one vertex must be supplied, or else the problem can
be run as a H-representation.</font></ul>
<font color="#FF0000"><b>Invalid Co-bas</b>is - does not have correct rank</font>
<ul><font color="#000000">An attempt to restart from an invalid cobasis
has been made. Check that the indices are entered exactly as they appear
in the previous aborted run.</font></ul>
<b><font color="#FF0000">Maximize/minimize only valid for H-representation</font></b>
<ul><font color="#000000">LP operations can only be performed on H-representations.</font></ul>
<b><font color="#FF0000">No begin line</font></b>
<ul><font color="#000000">Input file does not contain a begin line. See
<a href="#File Formats">File
Formats.</a></font></ul>
<b><font color="#FF0000">No data in file</font></b>
<ul><font color="#000000">The input file is incorrect, please check <a href="#File Formats">File
Formats.</a></font></ul>
<b><font color="#FF0000">No feasible solution</font></b>
<ul><font color="#000000">The input is an H-representation of an infeasible
system.</font></ul>
<b><font color="#FF0000">Starting cobasis indices must be distinct and
in range 1 .. m</font></b>
<ul><font color="#000000">The startingcobasis option has been used, but
the indices supplied were not valid: i.e. distinct numbers between 1..m.</font></ul>
<b><font color="#FF0000">Trying to restart from infeasible dictionary</font></b>
<ul><font color="#000000">An attempt to restart from an invalid cobasis
has been made. Check that the indices are entered exactly&nbsp; in the
order appear in the previous aborted run.</font></ul>

<h3>

<hr WIDTH="100%"><a NAME="Hints and Comments"></a><font color="#000000">Hints
and Comments</font></h3>

<h4>
<a NAME="H- vs V- representation"></a><font color="#000000">H- vs V- representation</font></h4>
<font color="#000000">&nbsp;<i>lrs</i> is programmed to manipulate H-representations
directly. A file presented as a V-representation is processed by lifting
it to a cone in one higher dimension, which is treated internally as a
H-representation. If the input file is a polytope which contains the origin,
then the user has two options. Submit it as a V-representation and have
it processed as just described, or submit it as a H-representation, and
interpret the output as a list of facet inequalities rather than "vertices".
Since this will not be lifted, it will be processed in a different way
by <i>lrs</i>. Sometimes a degenerate V-representation may run more quickly
as a H-representation, and sometimes more slowly. To decide which representation
to use for a large problem, the user can run the </font><b><font color="#3333FF">estimates</font></b><font color="#000000">option
and choose the representation with fewest estimated bases.</font>
<br>&nbsp;
<h4>
Redundancy vs Degeneracy</h4>
For an H-representation, an input is redundant if some inequality can be
deleted without changing the polyhedron. It is degenerate if (in d dimensions)
at least one vertex lies on d+1 or more facets.&nbsp; Similarly in a V-representation
an input is redundant if some input point is not a vertex of the convex
hull.&nbsp; It is degenerate if some facet contains d+1 or more input points.
The <a href="#Options">options</a>&nbsp; <b><font color="#000099">printcobasis</font></b>
and <b><font color="#000099">incidence</font></b> give degeneracy information.
Degeneracy causes pivot&nbsp; or triangulation based methods such as<i>
lrs </i>to&nbsp; run slowly. Redundancy is one cause of degeneracy, but
it can be avoided by pre-processing the input files. See section <a href="#Extreme Point Enumeration and Redundant Inequalities">Extreme
Point Enumeration and Redundant Inequalities</a> for instructions on how
to do this. This pre-processing is unnecessary if it is known that the
input is non-redundant.
<p>Even with redundant input removed a polyhedron may be highly degenerate.
In directory <a href="ftp://mutt.cs.mcgill.ca/pub/C">ine/metric </a>there
are many highly degenerate combinatorial polytopes. These are difficult
problems for all vertex enumeration/convex hull programs that use pivoting,
such as <i>lrs</i>.&nbsp; For example, the file <i>ccc7.ine</i> is a cone
with 63 facets in 21 dimensions. It has 38,780 extreme rays, but computing
these required the evaluation of 247,271,659 bases!
<h4>
<font color="#000000">Memory considerations</font></h4>
<font color="#000000">The strong point of <i>lrs</i> is that it does not
save the output produced, so in theory it cannot run out of memory.&nbsp;
With cache size one all memory is allocated at the beginning, so if <i>lrs</i>
starts running it will not run out of memory. It is possible however that
the number of digits required to do the calculations exceeds the amount
specified on the </font><b><font color="#000099">digits</font></b><font color="#000000">
option, or the default. In practice, this problem will also arise early
in the computation. In any case, a message is printed and the calculation
can be restarted. In order to improve performance, some dictionaries should
be cached. The default of 10 can be overridden by the </font><b><font color="#000099">cache</font></b><font color="#000000">option.
If the dictionary is in the cache it does not need to be recomputed when
backtracking, reducing&nbsp; processing time by about 40%. Since the cache
is allocated dynamically, a cache size that is too large can potentially
use up large ammounts of machine memory.</font>
<h4>
Geometric Rays</h4>
A minimum V-representation of a polyhedron is a minimum set of vertices
and rays such that each point in the polyhedron can be expressed as a convex
combination of vertices plus a non-negative combination of rays. For the
cube, if we delete the inequality
<br>x<sub>3</sub> &lt;= 1, i.e.. the line 1 0 0 -1 from file <i>cube.ine</i>,
we get the output:
<br><b><font color="#FF0000">V-representation</font></b>
<br><b><font color="#FF0000">***** 4 rational</font></b>
<br><b><font color="#FF0000">1 1 1 -1</font></b>
<br><b><font color="#FF0000">0 0 0 1</font></b>
<br><b><font color="#FF0000">1 -1 1 -1</font></b>
<br><b><font color="#FF0000">1 1 -1 -1</font></b>
<br><b><font color="#FF0000">1 -1 -1 -1</font></b>
<br><b><font color="#FF0000">end</font></b>
<br>indicating the polyhedron is the convex combination of 4 vertices and
1 ray. With the <b><font color="#000099">geometric</font></b> option, we
get the output:
<br><b><font color="#FF0000">V-representation</font></b>
<br><b><font color="#FF0000">begin</font></b>
<br><b><font color="#FF0000">***** 4 rational</font></b>
<br><b><font color="#FF0000">1 1 1 -1</font></b>
<br><b><font color="#FF0000">0 0 0 1&nbsp; * 1 1 1 -1</font></b>
<br><b><font color="#FF0000">1 -1 1 -1</font></b>
<br><b><font color="#FF0000">0 0 0 1&nbsp; * 1 -1 1 -1</font></b>
<br><b><font color="#FF0000">1 1 -1 -1</font></b>
<br><b><font color="#FF0000">0 0 0 1&nbsp; * 1 1 -1 -1</font></b>
<br><b><font color="#FF0000">1 -1 -1 -1</font></b>
<br><b><font color="#FF0000">0 0 0 1&nbsp; * 1 -1 -1 -1</font></b>
<br><b><font color="#FF0000">end</font></b>
<br>This indicates that geometrically, the polyhedron has 4 parallel extreme
rays (0,0,t) , one incident to each vertex. With the <b><font color="#000099">geometric</font></b>
option, all rays will be printed. Without the option, <i>lrs </i>tries
to print each ray once, but in some cases duplicates will remain, see&nbsp;
subsection Output Duplication.
<br><a NAME="Output Duplication"></a>
<br><b>Output Duplication</b>
<p>For degenerate inputs, pivot based methods such as <i>lrs</i> may generate
the same output vertex/ray/facet many times. Unless the <b><font color="#000099">allbases
</font></b>option
is specified, <i>lrs</i> makes checks in order to remove duplicates.&nbsp;
An output is only printed when it occurs with a lexicographically minimum
basis. This removes all duplicate vertices, but rays/facets may still be
output more than once. This is due to the fact that duplicate geometric
rays cannot always be detected. A warning message is produced when duplicates
may occur in the output. They can be removed using the program <i>buffer.c</i>.
Two important types of input never produce duplicate output: polytopes
(i.e. bounded polyhedra) and cones (i.e. polyhedra where the origin is
the only vertex).
<h3>

<hr WIDTH="100%"><a NAME="Acknowledgements"></a>Acknowledgements and References</h3>
I would like to thank many people for helping with this implementation
project. Komei Fukuda encouraged me from the start, collaborated in designing
the file formats, and provided many suggestions for improving the code.
Debugging would have been almost impossible without the use of his program
cdd as a benchmark. David Bremner implemented memory allocation, cacheing
and signals. Ambros Marzetta demonstrated the importance of cacheing and
lrslong is based on his earlier implementation of this as prs_single.&nbsp;
Jerry Quinn coded the integer divide routine. Bug reports were provided
by many users, for which I thank them. In particular Gerardo Garbulsky's
extensive use of earlier versions suggested many refinements and Andreas
Enge helped debug the volume computation.
<p>D. Avis, lrs: A Revised Implementation of the Reverse Search Vertex
Enumeration Algorithm, <a href="ftp://mutt.cs.mcgill.ca/pub/doc/avis/Av98a.ps.gz">ftp://mutt.cs.mcgill.ca/pub/doc/avis/Av98a.ps.gz</a>
May 1998.
<p>D. Avis, "Computational Experience with the Reverse Search Vertex Enumeration
Algorithm," Optimization Methods and Software, (1998 (to appear)).<a href="ftp://mutt.cs.mcgill.ca/pub/doc/avis/Av98b.ps.gz">
ftp://mutt.cs.mcgill.ca/pub/doc/avis/Av98b.ps.gz</a>
<p>D. Avis, D. Bremner, and R. Seidel, "How Good are Convex Hull Algorithms?,"
Computational Geometry: Theory and Applications, Vol 7,pp.265-301(1997).
<a href="ftp://mutt.cs.mcgill.ca/pub/doc/avis/ABS96a.ps.gz">ftp://mutt.cs.mcgill.ca/pub/doc/avis/ABS96a.ps.gz</a>
<p>D. Avis and L. Devroye, "Estimating the Number of Vertices of a Polyhedron,"
pp. 179-190 in Snapshots of Computational and Discrete Geometry, ed. D.
Avis and P. Bose, School of Computer Science, McGill University (1994).
<a href="ftp://mutt.cs.mcgill.ca/pub/doc/avis/AD94a.ps.gz">ftp://mutt.cs.mcgill.ca/pub/doc/avis/AD94a.ps.gz</a>
<p>D. Avis and K. Fukuda, "A Pivoting Algorithm for Convex Hulls and Vertex
Enumeration of Arrangements and Polyhedra," Discrete and Computational
Geometry, Vol. 8, pp. 295-313 (1992).&nbsp; <a href="ftp://mutt.cs.mcgill.ca/pub/doc/avis/AF92b.ps.gz">ftp://mutt.cs.mcgill.ca/pub/doc/avis/AF92b.ps.gz</a>
<p>D. Bremner, K. Fukuda and A. Marzetta, Primal-Dual Methods for Vertex
and Facet Enumeration, 13th ACM
<br>Symposium on Computational Geometry SCG 1997, 49-56.
</body>
</html>
