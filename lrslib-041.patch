diff -r -U 3 lrslib-041/lrsgmp.c /homes/combi/Projects/polymake/external/lrslib-041/lrsgmp.c
--- lrslib-041/lrsgmp.c	Tue Apr  3 23:51:15 2001
+++ /homes/combi/Projects/polymake/external/lrslib-041/lrsgmp.c	Fri Dec 14 12:08:06 2001
@@ -341,11 +341,16 @@
   lrs_digits = 0;		/* not used for gmp arithmetic  */
 
   lrs_alloc_mp(temp1); lrs_alloc_mp(temp2); lrs_alloc_mp(temp3);
-
+#ifndef LRS_QUIET
   printf(" gmp v.%d.%d",__GNU_MP_VERSION,__GNU_MP_VERSION_MINOR);
-
+#endif
   return TRUE;
 }
+
+void lrs_mp_close()
+{
+   lrs_clear_mp(temp1); lrs_clear_mp(temp2); lrs_clear_mp(temp3);
+}
 
 void 
 notimpl (char s[])
diff -r -U 3 lrslib-041/lrsgmp.h /homes/combi/Projects/polymake/external/lrslib-041/lrsgmp.h
--- lrslib-041/lrsgmp.h	Tue Apr  3 23:50:32 2001
+++ /homes/combi/Projects/polymake/external/lrslib-041/lrsgmp.h	Fri Dec 14 14:38:22 2001
@@ -151,6 +151,7 @@
 /******************************************************* */
 
 long lrs_mp_init (long dec_digits, FILE * lrs_ifp, FILE * lrs_ofp);	/* max number of decimal digits, fps   */
+void lrs_mp_close ();
 
 #define lrs_alloc_mp(a)		(mpz_init (a) )
 #define lrs_clear_mp(a)		(mpz_clear (a) )
@@ -200,8 +201,11 @@
 
 void stringcpy (char *s, char *t);	/* copy t to s pointer version                            */
 
+#ifndef __STDC__
 void *calloc ();
 void *malloc ();
+#endif
+
 void *xcalloc (long n, long s, long l, char *f);
 
 void lrs_default_digits_overflow ();
diff -r -U 3 lrslib-041/lrslib.c /homes/combi/Projects/polymake/external/lrslib-041/lrslib.c
--- lrslib-041/lrslib.c	Tue Jun 26 22:38:42 2001
+++ /homes/combi/Projects/polymake/external/lrslib-041/lrslib.c	Thu May  2 21:40:46 2002
@@ -1254,7 +1254,9 @@
 /* Do dual pivots to get primal feasibility */
   if (!primalfeasible (D, Q))
     {
+#ifndef LRS_QUIET
       fprintf (lrs_ofp, "\nNo feasible solution");
+#endif
       return FALSE;
     }
 
@@ -1269,12 +1271,12 @@
 /* Now solve LP if objective function was given */
   if (Q->maximize || Q->minimize)
     {
-      lrs_solvelp (D, Q, Q->maximize);
+      Q->unbounded = !lrs_solvelp (D, Q, Q->maximize);
       if (Q->lponly)		
         {
-         fprintf (lrs_ofp, "\nNumber of pivots for optimum solution: %ld",Q->count[3]);
          if (Q->verbose)
          {
+           fprintf (lrs_ofp, "\nNumber of pivots for optimum solution: %ld",Q->count[3]);
            printA (D, Q);
           }
           lrs_clear_mp(Temp); lrs_clear_mp(scale);
@@ -2163,8 +2165,8 @@
         changesign (Q->objnum);
   if (zero (Q->objnum))
         storesign (Q->objnum, POS);
-
-   reduce (Q->objnum,Q->objden);
+  else
+	reduce (Q->objnum,Q->objden);
 
 
   lrs_clear_mp(Ns); lrs_clear_mp(Nt); lrs_clear_mp(Ars);
@@ -2230,8 +2232,10 @@
 
   if (j < d && i == 0)		/* selectpivot gives information on unbounded solution */
     {
+#ifndef LRS_QUIET
       if (Q->lponly)
 	fprintf (lrs_ofp, "\n*Unbounded solution");
+#endif
       return FALSE;
     }
    if (Q->verbose)
@@ -2283,7 +2287,9 @@
 	{
 	  if (Q->debug)
 	    printA (P, Q);
+#ifndef LRS_QUIET
 	  fprintf (lrs_ofp, "\nCannot find linearity in the basis");
+#endif
 	  return FALSE;
 	}
       if (i <= m)
@@ -2301,14 +2307,18 @@
 	    {			/* cannot pivot linearity to cobasis */
 	      if (zero (A[Row[i]][0]))
 		{
+#ifndef LRS_QUIET
 		  fprintf (lrs_ofp, "\n*Input linearity in row %ld is redundant--skipped", order[j]);
+#endif
 		  linearity[j] = 0;
 		}
 	      else
 		{
 		  if (Q->debug)
 		    printA (P, Q);
+#ifndef LRS_QUIET
 		  fprintf (lrs_ofp, "\nInconsistent linearities");
+#endif
 		  return FALSE;
 		}
 	    }			/* end if j < nlinearity */
@@ -2457,7 +2467,7 @@
   P1->j = P->j;
   P1->depth = P->depth;
   P1->m = P->m;
-  P1->d = P->d;
+  P1->d = P1->d_orig = d;
   P1->lexflag = P->lexflag;
   P1->m_A = P->m_A;
   copy (P1->det, P->det);
@@ -3480,7 +3490,7 @@
 /* do the same steps as for allocation, but backwards */
 /* gmp variables cannot be cleared using free: use lrs_clear_mp* */
   lrs_dic *P1;
-  long d = P->d;
+  long d = P->d_orig;
   long m_A = P->m_A;
 
 /* repeat until cache is empty */
@@ -3615,7 +3625,7 @@
 
 /* Initializations */
 
-  p->d = d;
+  p->d = p->d_orig = d;
   p->m = m;
   p->m_A  = m_A;
   p->depth = 0L;
diff -r -U 3 lrslib-041/lrslib.h /homes/combi/Projects/polymake/external/lrslib-041/lrslib.h
--- lrslib-041/lrslib.h	Tue Jun 26 22:39:05 2001
+++ /homes/combi/Projects/polymake/external/lrslib-041/lrslib.h	Thu May  2 18:31:01 2002
@@ -89,6 +89,7 @@
     long m;			/* A has m+1 rows, row 0 is cost row            */
     long m_A;           	/* =m or m-d if nonnegative flag set            */
     long d;			/* A has d+1 columns, col 0 is b-vector         */
+    long d_orig;		/* value of d as A was allocated  (E.G.)        */
     long lexflag;		/* true if lexmin basis for this vertex         */
     long depth;			/* depth of basis/vertex in reverse search tree */
     long i, j;			/* last pivot row and column pivot indices      */
@@ -109,7 +110,7 @@
     lrs_mp Dvolume;		/* volume denominator                           */
     lrs_mp objnum;		/* objective numerator value                    */
     lrs_mp objden;		/* objective denominator value                  */
-
+    long unbounded;		/* lp unbounded */
     char fname[100];		/* input file name from line 1 of input         */
 
     long *inequality;		/* indices of inequalities corr. to cobasic ind */
